#include <algorithm>
#include <fstream>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <random>
#include <set>
#include <string>
#include <vector>

#define MAXIMUM     std::numeric_limits<unsigned int>::max()
#define ROWNUM      9
#define PLAYER_THREAT       2
#define OPPONENT_FORBIDDEN  2
#define OPPONENT_THREAT     1

struct Square
{
	Square ( int first, int second, int third, int fourth ) : m_first(first), m_second(second), m_third(third), m_fourth(fourth) {}
	int		m_first;
	int		m_second;
	int		m_third;
	int		m_fourth;
	bool operator< ( const Square s ) const
	{
        if ( m_first < s.m_first
			|| (m_first == s.m_first && m_second < s.m_second)
			|| (m_first == s.m_first && m_second == s.m_second && m_third < s.m_third)
			|| (m_first == s.m_first && m_second == s.m_second && m_third == s.m_third && m_fourth < s.m_fourth) )
			return true;
        return false;
    }
	bool operator== ( const Square s ) const
	{
        if ( m_first == s.m_first && m_second == s.m_second && m_third == s.m_third && m_fourth == s.m_fourth )
			return true;
        return false;
    }
};

// rotates index i around index j by -pi/4
// returns either the index of a field or -1 if the result is outside the field
int Rotate ( const int i, const int j )
{
	int first = j/ROWNUM + ( j%ROWNUM - i%ROWNUM );
	int second = j%ROWNUM - ( j/ROWNUM - i/ROWNUM );
	if ( first < 0 || first > ROWNUM-1 || second < 0 || second > ROWNUM-1 )
		return -1; // if one of the coordinates is outside the interval [0,8]
	return first * ROWNUM + second;
}

// "sorts" input integers i,j,k and l ( {a,b,c,d} = {i,j,k,l} and a<b<c<d will be satisfied )
void Order ( const int i, const int j, const int k, const int l, int & a, int & b, int & c, int & d )
{
	int toSort[] = {i,j,k,l};
	std::vector<int> sortVector (toSort, toSort+4);
	std::sort (sortVector.begin(), sortVector.begin()+4);
	a = sortVector[0];
	b = sortVector[1];
	c = sortVector[2];
	d = sortVector[3];
}

// generate set of squares ( ordered 4-tuples of fields which form a square )
void GenerateSquares ( std::set<Square> & squareSet )
{
	// method: every square has either exactly one vertex in row k and no vertex in rows 0,...,k-1 ("tilted" squares)
	//                          or two vertices in row k and no vertex in rows 0,...,k-1 ("straight" squares)
	// therefore every square can be generated by picking the index of its smallest index,
	// then the index of the counterclockwise next vertex (this must be on the RHS of the smallest index!);
	// the other two vertices are now determined, what remains is to check if all four are on the board
	// and to make sure they are ordered when initializing the Square object
	for ( int i = 0; i < ROWNUM*ROWNUM; i++ ) // first choose the vertex with the smallest index (i)
	{
		for ( int j = i+1; j < ROWNUM*ROWNUM; j++ ) // then pick the next vertex (j)
		{
			if ( j%ROWNUM <= i%ROWNUM ) // if j is not on the RHS of i, i won't be the smallest index of the generated square
				continue;
			int k = Rotate(i,j); // the other two vertices can be determined by rotating first i around j by -pi/4
			int l = Rotate(j,k); // and then j around k by -pi/4
			if ( k == -1 || l == -1 ) // Rotate returns -1 iff the result of the rotation is outside the field
				continue;
			int a, b, c, d;
			Order( i,j,k,l, a,b,c,d ); // to initialize the Square object, first we need to order the four vertices
			squareSet.insert( Square(a, b, c, d) );
		}
	}
}

// sort fields ( = integers 0-80) into sets playerPositions, opponentPositions and map emptyFields
// depending on board and player
void ProcessInput ( const char player, const std::vector<std::string> & board,
                        std::set<int> & playerPositions, std::set<int> & opponentPositions,
                        std::map<int, unsigned int> & emptyFields )
{
    // process the string vector "line by line"
    // the kth character of the lth string determines where to insert k*9 + l
    unsigned int row = 0;
    for ( std::vector<std::string>::const_iterator it = board.begin(); it != board.end(); it++, row++ )
    {
        for ( unsigned int i = 0; i < ROWNUM; i++ )
        {
            if ( (*it)[i] == player )
                playerPositions.insert(row * ROWNUM + i);
            else if ( (*it)[i] == '-' )
                emptyFields[row * ROWNUM + i] = 0;
            else
                opponentPositions.insert(row * ROWNUM + i);
        }
    }
}

// increase penalties using values defined for one player
void CheckOnesPositions ( std::map<int, unsigned int> & emptyFields,
                                const std::set<int> & positions, const std::set<int> & otherPositions,
                                const std::set<Square> & squareSet, const bool player )
{
    // in the documentation of this function, if boolean input parameter is true than "current_player" means us, otherwise the opponent
    // ROUGH IDEA:
    // for each square we count how many of its vertices belong to current_player,
    // and we increase the penalty of its uncontrolled vertices depending on this number and the current_player
    //    for example, if the current_player is us and for the current square we/current_player controls three vertices,
    //    then the penalty for choosing the last vertex should be huge (the largest possible, to be precise);
    //    while if the current_player is the opponent and for the current square she controls two vertices,
    //    then the penalty for choosing one of the other vertices should be slightly increased (as later she might lose after forced to complete this square)

    // for each square
    for ( std::set<Square>::const_iterator squareIt = squareSet.begin(); squareIt != squareSet.end(); squareIt++ )
    {
        // if there is any the four vertices controlled by the other player (not current_player), then we can skip this square, current_player won't lose by completing this square
        if ( otherPositions.find( (*squareIt).m_first ) != otherPositions.end() ||
              otherPositions.find( (*squareIt).m_second ) != otherPositions.end() ||
              otherPositions.find( (*squareIt).m_third ) != otherPositions.end() ||
              otherPositions.find( (*squareIt).m_fourth ) != otherPositions.end() )
            continue;
        // from now on every vertex of the square is controlled by current_player or empty (and since the game is still on, at least one is empty)
        unsigned int found = 0; // to keep track which vertices are empty
        if ( positions.find( (*squareIt).m_first ) != positions.end() )
            found += 1;
        if ( positions.find( (*squareIt).m_second ) != positions.end() )
            found += 2;
        if ( positions.find( (*squareIt).m_third ) != positions.end() )
            found += 4;
        if ( positions.find( (*squareIt).m_fourth ) != positions.end() )
            found += 8;
        // we increase the penalties of the empty vertices of a square if two (found = 3,5,6,9,10,12) or three (found = 7,11,13,14) vertices are occupied by current_player
        // in each case, we increase the penalty of each empty field (unless it is already maximal)
        // if two fields are empty, we use PLAYER_THREAT or OPPONENT_THREAT (depending on current_player)
        // if only one field is empty, we use MAXIMUM or OPPONENT_FORBIDDEN similarly
        switch ( found )
        {
            case 3 :
                if ( emptyFields[(*squareIt).m_third] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_third] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_third] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_fourth] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_fourth] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_fourth] += OPPONENT_THREAT;
                break;
            case 5 :
                if ( emptyFields[(*squareIt).m_second] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_second] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_second] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_fourth] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_fourth] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_fourth] += OPPONENT_THREAT;
                break;
            case 9 :
                if ( emptyFields[(*squareIt).m_second] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_second] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_second] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_third] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_third] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_third] += OPPONENT_THREAT;
                break;
            case 6 :
                if ( emptyFields[(*squareIt).m_first] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_first] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_first] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_fourth] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_fourth] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_fourth] += OPPONENT_THREAT;
                break;
            case 10 :
                if ( emptyFields[(*squareIt).m_first] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_first] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_first] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_third] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_third] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_third] += OPPONENT_THREAT;
                break;
            case 12 :
                if ( emptyFields[(*squareIt).m_first] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_first] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_first] += OPPONENT_THREAT;
                if ( emptyFields[(*squareIt).m_second] != MAXIMUM )
                    if ( player )
                        emptyFields[(*squareIt).m_second] += PLAYER_THREAT;
                    else
                        emptyFields[(*squareIt).m_second] += OPPONENT_THREAT;
                break;
            case 7 :
                if (  player )
                    emptyFields[(*squareIt).m_fourth] = MAXIMUM;
                else
                    if ( emptyFields[(*squareIt).m_fourth] != MAXIMUM )
                        emptyFields[(*squareIt).m_fourth] += OPPONENT_FORBIDDEN;
                break;
            case 11 :
                if (  player )
                    emptyFields[(*squareIt).m_third] = MAXIMUM;
                else
                    if ( emptyFields[(*squareIt).m_third] != MAXIMUM )
                        emptyFields[(*squareIt).m_third] += OPPONENT_FORBIDDEN;
                break;
            case 13 :
                if (  player )
                    emptyFields[(*squareIt).m_second] = MAXIMUM;
                else
                    if ( emptyFields[(*squareIt).m_second] != MAXIMUM )
                        emptyFields[(*squareIt).m_second] += OPPONENT_FORBIDDEN;
                break;
            case 14 :
                if (  player )
                    emptyFields[(*squareIt).m_first] = MAXIMUM;
                else
                    if ( emptyFields[(*squareIt).m_first] != MAXIMUM )
                        emptyFields[(*squareIt).m_first] += OPPONENT_FORBIDDEN;
        }
    }
}

// sets the penalties (= second member of elements in emptyFields) in two steps
void ClassifyEmptyFields ( std::map<int, unsigned int> & emptyFields,
                                const std::set<int> & playerPositions, const std::set<int> & opponentPositions,
                                const std::set<Square> & squareSet )
{
    // first increase penalties using values defined for the player
    CheckOnesPositions(emptyFields, playerPositions, opponentPositions, squareSet, true);
    // then increase penalties using values defined for the opponent
    CheckOnesPositions(emptyFields, opponentPositions, playerPositions, squareSet, false);
}

int Min ( const int a, const int b )
{
    return (a > b ? b : a);
}

// for a given field, returns the sum of distances from closer vertical and horizontal edge of the board
// (the distance from the closest corner of the board; for example, for fields 0, 8, 72 and 80 it returns 0, for 11 it returns 3)
int GetDistanceFromEdges( const int position )
{
    int verticalDist = Min(position%ROWNUM, ROWNUM - position%ROWNUM - 1);
    int horizontalDist = Min(position/ROWNUM, ROWNUM - position/ROWNUM - 1);
    return verticalDist + horizontalDist;
}

// using the map emptyFields, pick the result: a (random) field for which the penalty is minimal and
// for which the distance from the edge of the board is also minimal among the set of fields with minimal penalty
// (important: the distance is not a distance in geometric sense! see GetDistanceFromEdges function)
int PickSolution ( std::map<int,unsigned int> & emptyFields )
{
    unsigned int minimum = MAXIMUM; // stores the smallest penalty
    int distance = 2 * ROWNUM; // stores the minimum distance from the edge of the board for the smallest penalty
    std::list<int> choiceList; // the list of optimal solutions
    // we loop through the map, keeping track of the smallest penalty
    for ( std::map<int,unsigned int>::const_iterator it = emptyFields.begin(); it != emptyFields.end(); it++ )
    {
        // if the current field's penalty is smaller than the previous minimum, we clear the list, add the current field and set the minimum and distance accordingly
        if ( (*it).second < minimum )
        {
            choiceList.clear();
            choiceList.push_back((*it).first);
            minimum = (*it).second;
            distance = GetDistanceFromEdges((*it).first);
        }
        else if ( (*it).second == minimum )
            // if the current field's penalty is equal to the minimum and its distance is also equal to the current minimum, we add the current field to the list
            if ( distance == GetDistanceFromEdges((*it).first) )
                choiceList.push_back((*it).first);
            // if the current field's penalty is equal to the minimum and its distance is smaller than the minimum, we clear the list, add the current field and set the distance accordingly
            else if ( distance > GetDistanceFromEdges((*it).first) )
            {
                distance = GetDistanceFromEdges((*it).first);
                choiceList.clear();
                choiceList.push_back((*it).first);
            }
        // (in every other case no action is taken)
    }
    // we pick a random element from choiceList (possibly this step could be replaced by a better, deterministic one)
    std::random_device r;
    std::default_random_engine eng(r());
    std::uniform_int_distribution<int> uniform_dist(0,choiceList.size()-1);
    int choice = uniform_dist(eng);
    std::list<int>::iterator it = choiceList.begin();
    std::advance(it,choice);
    return *it;
}

// the main function of the code
void nextMove(char player, std::vector<std::string> board)
{
	// process input (board)
	// fields are indexed with integers 0,...,80 using the following substitution: field (i,j) -> i*9 + j
        std::set<int> playerPositions, opponentPositions; // set of player positions and her opponent's positions, resp.
        std::map<int,unsigned int> emptyFields; // pairs of empty fields and their penalty (latter initialized as 0 during processing, penalties will be determined later)
        ProcessInput(player, board, playerPositions, opponentPositions, emptyFields);
    // the struct Square consists of the _ordered_ 4-tuple of m_first,m_second,m_third,m_fourth
    // important: when initializing a Square, make sure its four members satisfy m_first < m_second < m_third < m_fourth
        std::set<Square> squareSet;
        GenerateSquares(squareSet); // this function generates the set of all squares of the field
    // set the penalties (second member) of emptyFields
        ClassifyEmptyFields(emptyFields, playerPositions, opponentPositions, squareSet);
    // find a field with minimal penalty closest to the board's edge
        int decision = PickSolution(emptyFields);
    // print the result coordinates to std::cout
        std::cout << decision/ROWNUM << " " << decision%ROWNUM << std::endl;
}

int main(void)
{
    char player;
    std::vector<std::string> board;
    // read input from std::cin
    std::cin >> player;
    for(int i=0; i<9; i++)
    {
        std::string s;
        std::cin >> s;
        board.push_back(s);
    }
    // determine the next move
    nextMove(player, board);

    return 0;
}
